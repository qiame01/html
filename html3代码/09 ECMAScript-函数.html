<!DOCTYPE html>
<html>
	<head>
		<meta charset="UTF-8">
		<title></title>
	</head>
	<body>
		<!--
			1.有名函数（普通的自定义函数）
				function 函数名(参数集){...}
				永远不会主动执行！
				
				调用：函数名();
			
			2.匿名函数
				function(){...}
		-->
	</body>
</html>
<script>
//	有名函数：注意细节========================================================================================
	// 细节1: 函数必须被调用,才会被执行
/*	function fn1(){
		alert("Hello World!");
	}
	fn1();*/
	
	// 细节2: 如果函数需要返回值 直接使用return返回即可,不需要指定返回类型
/*	function fn2(){
		return "12345";
	}
	alert(fn2());*/
	
	// 细节3: 如果需要传递参数,不需要指定类型
/*	function fn3(a,b){
		alert(a+b);
	}
	fn3('true',123);*/
//	fn3('true',123);//结果竟然是124！！！！
	
	// 细节4: 在js中不存在函数重载, 如果写了两个,后面的会把前面的覆盖掉
/*	function fn4(a,b){
		alert('123'+a+b);
	}
	function fn4(){
		alert('456');
	}
	fn4(1,2);*/
	
	// 细节5: 如果需要传递参数,但是我就不传,不会报错
/*	function fn5(a,b){
		alert(a+b);
	}
	fn5();*/
	
	// 细节6: 如果函数不需要传递参数, 我们却传参数, 不会报错,正常调用，但无法取得实参...对比下面的细节7
/*	function fn6(){
		alert('456');
		alert(a+b);
	}
	fn6(1,2)*/
	
	// 细节7: js提供arguments对象,类似于是数组,里面存储了调用时候传递的参数,无需形参也可以获取到参数...对比上面细节6
/*	function fn7(){
		console.log(arguments[1]);
		alert(arguments[0]);
	}
	fn7(1,'我们');*/
	
	// 细节8: 起别名时 函数不需要带括号 用别名调用时再加上括号，见下面的赋值调用
/*	function abcdefg(){
		alert(111111);
	}
	var abc = abcdefg();
	abc();
	*/
//匿名函数：2种调用方式：赋值调用、自调用========================================================================================
	/*var fn8 = function(){
		alert();
	}
	fn8();*/
	
/*	(function(){
		alert(12345);
	})();*/
	
</script>


